//
// Created by KK on 2022/3/20.
//


/**
 * KMP 算法是一种在一个主串中快速匹配另外一个模式串的算法。
 * 核心是对于已经比较过的字符串，可以在模式串中通过找到最长相等前后缀实现在主串中快速跳转。
 * 为什么是最长的相等前后缀呢？这是因为最长的相等前后缀可以使每次跳转的位置最短，防止错过可能的匹配情况。
 *
 * 洛谷 P3357 https://www.luogu.com.cn/problem/P3375
 *
 * 题目描述
 * 给出两个字符串 s1 和 s2，若 s1 的区间 [l,r] 子串与 s2 完全相同，则称 s2 在 s1 中出现了，其出现位置为 l。
 * 现在请你求出 s2 在 s1 中所有出现的位置。
 *
 * 定义一个字符串 s 的 border 为 s 的一个非 s 本身的子串 t，满足 t 既是 s 的前缀，又是 s 的后缀。
 * 对于 s2 ，你还需要求出对于其每个前缀 s' 的最长 border t' 的长度。
 *
 * 输入格式
 * 第一行为一个字符串，即为 s1。
 * 第二行为一个字符串，即为 s2。
 *
 * 输出格式
 * 首先输出若干行，每行一个整数，按从小到大的顺序输出 s2 在 s1 中出现的位置。
 * 最后一行输出 |s2| 个整数，第 i 个整数表示 s2 的长度为 i 的前缀的最长 border 长度
 *
 * 输入输出样例
 * 输入
 * ABABABC
 * ABA
 *
 * 输出
 * 1
 * 3
 * 0 0 1
 *
 * 对于全部的测试点，保证 1 ≤ ∣s1∣,∣s2∣ ≤ 10^6; s1,s2 中均只含大写英文字母。
 */


#include <cstdio>
#include <cstring>

using namespace std;

const int N = 1000010;
char s[N], p[N];
int next[N];

int main() {
  scanf("%s", s);
  scanf("%s", p);
  auto n = strlen(s);
  auto m = strlen(p);

  // next[i] 表示以索引 i 结尾的字符串中的最长相等前后缀的长度。
  // 很显然，当 i = 0 时， 只有一个字符， next[i] = 0;
  // 求 next 的过程实际也是匹配的过程
  for(int i = 1, j = 0; i <= m; ++i) {
    while(j && p[i] != p[j]) j = next[j - 1];
    if (p[i] == p[j]) j++;
    next[i] = j; // 每一个以索引 i 结尾的子串都需要更新长度
  }

  // 匹配的过程：
  // 主串的起始位置只影响从什么地方开始做匹配，与模式串的索引没有必然的联系，两者可以选取不同的实现方式。
  // 思想：假设主串从下标 0 开始做匹配，每次匹配后都会指向下一个字符，与此同时，当发现不匹配时根据模式串的最长相等前后缀来移动模式串。
  // 主串从 0 开始匹配，模式串的索引也从 0 开始
  // 如下图所示：
  // * 表示主串中已经匹配过但是匹配失败的字符串
  // - 表示主串与模式串都匹配的字符串
  // x 和 o 分别表示主串与模式串匹配失败的第一个字符
  // 在正常匹配时发现索引为 i 的字符匹配失败，那么需要在模式串中找到前面已经匹配的 [0, j - 1] 字符串中最长相等前后缀 next[j - 1]的长度。
  // 此时我们需要不停的往左寻找下一个与索引 i 匹配的字符(本质上就是模式串向右移动),
  // 如果模式串往左都没有找到与索引 i 匹配的字符，那么继续匹配 i + 1
  // 下标:    0         i-1 i
  // 主串:    *****-------- x
  // 下标:         0    j-1 j
  // 模式串:       -------- o

  for(int i = 0, j = 0; i < n; ++i) {
    // next 数组存储的是长度，而模式串始终都从头开始匹配，因此可以直接将长度转换为索引
    while(j && s[i] != p[j]) j = next[j - 1];  // 匹配失败
    if (s[i] == p[j]) j++; // 匹配成功
    if (j == m) { // 全部匹配成功
      printf("%d\n", i - m + 2); // i - m + 1 拿到的是索引，而题目要求是第几个位置，因此额外需要加 1
    }
  }

  // 注意 next[i] 表示模式串中以索引 i 结尾的子串中的最长相等前后缀的长度
  for(int i = 0; i < m; ++i) printf("%d ", next[i]);

  return 0;
}
