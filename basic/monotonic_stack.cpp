//
// Created by KK on 2022/3/9.
//

// 单调栈：洛谷p5788, https://www.luogu.com.cn/problem/P5788
/**
 * 题目描述
 * 给出项数为 n 的整数数列 a[1]....a[n]
 *
 * 定义函数 f(i) 代表数列中第 i 个元素之后第一个大于 a[i] 的元素的下标，若不存在，则 f(i) = 0。
 *
 * 试求出 f(1…n)。
 *
 * 输入格式
 * 第一行一个正整数 n。
 * 第二行 n 个正整数 a[1]....a[n]
 *
 * 输出格式
 * 一行 n 个整数 f(1…n) 的值。
 *
 * 输入输出样例
 * 输入
 * 5
 * 1 4 2 3 5
 *
 * 输出
 * 2 5 4 5 0
 *
 * 说明/提示
 * 【数据规模与约定】
 * 对于 30% 的数据, n ≤ 100;
 * 对于 60% 的数据，n ≤ 5×10^3
 * 对于 100% 的数据，1 ≤ n ≤ 3×10^6 1 ≤ a[i] ≤ 10^9
 */


#include <cstdio>

const int N = 3 * 1e6 + 10;
int n;
int top = 0; // 栈顶索引
int a[N], p[N], r[N]; // a[i] 读取的数据， p[i] 单调递减栈中对应数据的下标， r[i] 存储的最终结果

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);

  // 单调递减栈，从后往前遍历
  for (int i = n; i >= 1; --i) {
    // 当前遍历的数大于等于栈顶则将栈顶的数据依次出栈
    while (top && a[p[top]] <= a[i]) top--;
    // 为什么结果可以不判断栈的状态直接存储
    // 1. 如果栈为空，那么 top == 0, 结果也应该存入 0， 而 p[0] 在初始化时默认就是 0，后面操作也不会修改 p[0]
    // 2. 如果栈非空， 那么 r[i] 就应该存储栈顶的数据
    r[i] = p[top];
    p[++top] = i;
  }

  for (int i = 1; i <= n; ++i) printf("%d ", r[i]);
  return 0;
}


